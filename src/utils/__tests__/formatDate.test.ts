/**
 * Comprehensive тестирование утилитарной функции formatDate.
 *
 * КЛЮЧЕВЫЕ КОНЦЕПЦИИ:
 * 1. Тестирование утилит: изолированная проверка pure функций
 * 2. Edge Cases: граничные значения, невалидные входные данные
 * 3. Equivalence Partitioning: разделение входных данных на классы
 * 4. Boundary Value Analysis: тестирование границ
 * 5. Error Handling: обработка ошибочных входных данных
 *
 * СТРАТЕГИЯ ТЕСТИРОВАНИЯ:
 * - Нормальные случаи: обычные даты с разным форматированием
 * - Граничные случаи: начало/конец месяца, високосные годы
 * - Edge cases: невалидные даты, экстремальные значения
 * - Различные типы входов: Date объекты, числовые timestamp'ы
 * - Обработка ошибок: NaN, Infinity, невалидные строки
 */
import { describe, expect, it } from 'vitest';

import { formatDate } from '../formatDate';

describe('Утилита formatDate', () => {
    /**
     * БАЗОВЫЕ ФУНКЦИОНАЛЬНЫЕ ТЕСТЫ
     * Проверяют основную логику форматирования в типичных сценариях
     */

    it('должна форматировать дату, добавляя ведущие нули для дня и месяца', () => {
        // ARRANGE: Дата с однозначными день и месяц
        const date = new Date('2024-01-05T10:00:00');

        // ACT & ASSERT: Проверяем правильное добавление ведущих нулей
        expect(formatDate(date)).toBe('05.01.2024');
    });

    it('должна форматировать дату без добавления ведущих нулей для дня и месяца', () => {
        // ARRANGE: Дата с двузначными день и месяц
        const date = new Date('2024-10-15T10:00:00');

        // ACT & ASSERT: Проверяем, что ведущие нули не добавляются к двузначным числам
        expect(formatDate(date)).toBe('15.10.2024');
    });

    it('должна корректно обрабатывать часовые пояса, основываясь на локальных компонентах даты', () => {
        // ARRANGE: Дата с явным указанием часового пояса
        // Важно: функция должна использовать локальные компоненты даты
        const date = new Date('2024-01-01T02:00:00+03:00');

        // ACT & ASSERT: Проверяем независимость от часового пояса
        expect(formatDate(date)).toBe('01.01.2024');
    });

    /**
     * ГРАНИЧНЫЕ СЛУЧАИ (BOUNDARY CASES)
     * Тестируют поведение на границах: начало/конец месяца, високосные годы
     */

    it('должна корректно обрабатывать начало месяца', () => {
        // ARRANGE: Первое число месяца
        const date = new Date('2024-03-01T10:00:00');

        // ACT & ASSERT
        expect(formatDate(date)).toBe('01.03.2024');
    });

    it('должна корректно обрабатывать конец месяца', () => {
        // ARRANGE: Последний день февраля в високосном году
        const date = new Date('2024-02-29T10:00:00');

        // ACT & ASSERT: Проверяем обработку 29 февраля
        expect(formatDate(date)).toBe('29.02.2024');
    });

    it('должна корректно обрабатывать високосный год', () => {
        // ARRANGE: 29 февраля в високосном году (каждые 4 года, кроме столетий)
        const leapDate = new Date('2024-02-29T12:00:00');

        // ACT & ASSERT: Проверяем корректную обработку високосного года
        expect(formatDate(leapDate)).toBe('29.02.2024');
    });

    it('должна корректно обрабатывать невисокосный год', () => {
        // ARRANGE: Последний день февраля в обычном году
        const nonLeapDate = new Date('2023-02-28T12:00:00');

        // ACT & ASSERT
        expect(formatDate(nonLeapDate)).toBe('28.02.2023');
    });

    /**
     * РАЗЛИЧНЫЕ ТИПЫ ВХОДНЫХ ДАННЫХ
     * Функция должна принимать как Date объекты, так и числовые timestamp'ы
     */

    it('должна корректно форматировать дату из числового таймстампа', () => {
        // ARRANGE: Unix timestamp в миллисекундах
        const timestamp = 1704067200000; // 1 января 2024

        // ACT & ASSERT: Проверяем преобразование timestamp в дату
        expect(formatDate(timestamp)).toBe('01.01.2024');
    });

    it('должна корректно обрабатывать Unix epoch', () => {
        // ARRANGE: Начало Unix времени (эпоха)
        const epochTimestamp = 0; // 1 января 1970, 00:00:00 UTC

        // ACT & ASSERT: Базовая точка отсчета времени в Unix
        expect(formatDate(epochTimestamp)).toBe('01.01.1970');
    });

    it('должна корректно обрабатывать отрицательные timestamp', () => {
        // ARRANGE: Дата до Unix epoch
        const timestamp = -86400000; // 31 декабря 1969 (сутки до epoch)

        // ACT & ASSERT: Проверяем работу с датами до 1970 года
        expect(formatDate(timestamp)).toBe('31.12.1969');
    });

    /**
     * EDGE CASES: НЕВАЛИДНЫЕ И ЭКСТРЕМАЛЬНЫЕ ЗНАЧЕНИЯ
     * Критически важно тестировать обработку ошибочных входных данных
     */

    it('должна обрабатывать невалидные даты', () => {
        // ARRANGE: Создаем Date объект с невалидной строкой
        const invalidDate = new Date('invalid-date');

        // ACT & ASSERT: При невалидной дате должно возвращаться "Invalid Date"
        expect(formatDate(invalidDate)).toBe('Invalid Date');
    });

    it('должна обрабатывать NaN как timestamp', () => {
        // ARRANGE: NaN - результат неудачных математических операций

        // ACT & ASSERT: NaN должен обрабатываться как невалидная дата
        expect(formatDate(NaN)).toBe('Invalid Date');
    });

    it('должна обрабатывать Infinity как timestamp', () => {
        // ARRANGE: Положительная бесконечность

        // ACT & ASSERT: Infinity выходит за пределы валидных дат JavaScript
        expect(formatDate(Infinity)).toBe('Invalid Date');
    });

    it('должна обрабатывать -Infinity как timestamp', () => {
        // ARRANGE: Отрицательная бесконечность

        // ACT & ASSERT
        expect(formatDate(-Infinity)).toBe('Invalid Date');
    });

    /**
     * ГРАНИЧНЫЕ ЗНАЧЕНИЯ JAVASCRIPT DATE
     * JavaScript Date имеет ограничения: от -8,640,000,000,000,000 до 8,640,000,000,000,000 мс
     */

    it('должна корректно обрабатывать граничные значения JavaScript Date', () => {
        // ARRANGE: Максимальное значение для JavaScript Date
        const maxDate = new Date(8640000000000000); // Максимум: ~271,821 до н.э.

        // ACT & ASSERT: За пределами диапазона должно возвращать "Invalid Date"
        expect(formatDate(maxDate)).toBe('Invalid Date');
    });

    it('должна корректно обрабатывать экстремальные даты за пределами JS', () => {
        // ARRANGE: Минимальное значение для JavaScript Date
        const minDate = new Date(-8640000000000000); // Минимум: ~271,821 н.э.

        // ACT & ASSERT
        expect(formatDate(minDate)).toBe('Invalid Date');
    });

    /**
     * ТЕСТЫ НА РЕАЛЬНЫХ ИСТОРИЧЕСКИХ ДАТАХ
     * Проверяем работу с реальными датами из практического диапазона
     */

    it('должна корректно обрабатывать экстремально маленькие даты', () => {
        // ARRANGE: Дата из начала 20 века
        const date = new Date('1900-01-01T00:00:00');

        // ACT & ASSERT: Проверяем работу с историческими датами
        expect(formatDate(date)).toBe('01.01.1900');
    });

    it('должна корректно обрабатывать экстремально большие даты', () => {
        // ARRANGE: Дата из далекого будущего (но в пределах разумного)
        const date = new Date('2099-12-31T23:59:59');

        // ACT & ASSERT: Проверяем работу с будущими датами
        expect(formatDate(date)).toBe('31.12.2099');
    });
});
