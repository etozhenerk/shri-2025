# Руководство по написанию интеграционных тестов (Vitest + RTL)

Этот документ описывает правила и лучшие практики для написания интеграционных тестов с использованием Vitest и React Testing Library (RTL). Интеграционные тесты — наш основной инструмент для проверки функциональности приложения.

## 1. Основные принципы

-   **Цель:** Проверить взаимодействие нескольких компонентов, хуков и сторов (Zustand) без использования реального браузера.
-   **Среда:** `jsdom` (эмуляция DOM).
-   **Ключевой вопрос:** "Что видит и делает пользователь?". Тест должен имитировать действия пользователя и проверять результат на "экране" (в отрендеренном DOM).

## 2. Структура теста

Каждый интеграционный тест должен следовать четкой структуре:

1.  **Импорты:** Вверху файла импортируются все необходимые утилиты (`describe`, `test`, `expect`, `renderWithProviders`, `fireEvent`, `screen`, `waitFor`).
2.  **`describe` блок:** Тесты для одного компонента или страницы группируются в `describe` блок. Это соответствует общим правилам проекта, требующим `describe` в юнит- и интеграционных тестах.
3.  **`test` блок:** Каждый `test` описывает один конкретный сценарий.
4.  **Рендеринг:** Внутри теста тестируемый компонент рендерится с помощью нашей утилиты `renderWithProviders`.
5.  **Действия:** События пользователя эмулируются через `fireEvent` или `userEvent`.
6.  **Проверки:** Результат проверяется с помощью `expect` и запросов из `screen`.

## 3. Ключевые утилиты и техники

### Рендеринг компонентов

Для рендеринга компонентов используется стандартная функция `render` из `@testing-library/react`.

**Важно:** Если компонент использует навигацию (например, содержит `<Link>`), его необходимо обернуть в `<MemoryRouter>`:
```typescript
import { render } from '@testing-library/react';
import { MemoryRouter } from 'react-router-dom';
import { HomePage } from '../HomePage';

render(
    <MemoryRouter>
        <HomePage />
    </MemoryRouter>
);
```

В будущем, при усложнении приложения, может быть создана утилита `renderWithProviders`.

### Взаимодействие с элементами (`fireEvent` vs `userEvent`)

-   `@testing-library/user-event` — это высокоуровневая симуляция, которая имитирует полное поведение пользователя (например, `userEvent.click` вызовет `hover`, `focus`, `mousedown`, `mouseup`, `click`).
-   `@testing-library/react` (`fireEvent`) — это низкоуровневая утилита, которая вызывает только одно конкретное событие (например, `fireEvent.change`).

-   **Критическое правило:** В ходе отладки `HomePage.integration.test.tsx` мы выяснили, что `userEvent.upload` не работает корректно с нашим компонентом `Dropzone`.
    -   **Решение:** Для загрузки файлов необходимо использовать низкоуровневый **`fireEvent.change`**.

    ```typescript
    // ПРАВИЛЬНО (используем fireEvent)
    const fileInput = screen.getByTestId('dropzone');
    fireEvent.change(fileInput, { target: { files: [file] } });

    // НЕПРАВИЛЬНО (userEvent.upload не работает в нашем случае)
    // await userEvent.upload(fileInput, file);
    ```

### Работа со стором (Zustand)

Для проверки состояния стора или его мокирования в тестах:

-   **Мокирование Actions:** Можно использовать `vi.spyOn` для отслеживания вызовов actions.
-   **Проверка состояния:** Состояние можно импортировать напрямую из стора и проверять его изменения.
-   **Сброс состояния:** Используйте `beforeEach` или `afterEach` для сброса состояния стора между тестами, чтобы обеспечить их независимость.

    ```typescript
    import { analysisStore } from '@/store/analysisStore';

    const initialState = analysisStore.getState();

    beforeEach(() => {
        analysisStore.setState(initialState);
    });
    ```

## 4. Конфигурация

-   **`vitest.config.ts`:** Должен быть настроен для работы с React, включая `environment: 'jsdom'` и `setupFiles`.
-   **`tsconfig.json`:** Убедитесь, что в `compilerOptions.types` включены `"@testing-library/jest-dom"`, чтобы работали матчеры вроде `.toBeVisible()`.

## Запуск тестов

Интеграционные тесты теперь являются частью функциональных E2E-тестов и запускаются через Playwright. Для запуска используйте команду:

```bash
npm run test:functional
```

Для удобной отладки доступен интерактивный режим:

```bash
npm run test:e2e:ui
```

### Проверка на нестабильность

Для проверки тестов на нестабильность используйте:
- `npm run test:flaky` - для проверки отдельного теста
- `npm run test:flaky:all` - для проверки всех тестов 